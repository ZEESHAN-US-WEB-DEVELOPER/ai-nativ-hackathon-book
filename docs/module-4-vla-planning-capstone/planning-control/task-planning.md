# Task Planning

Task planning reasons at a high level about what actions to take to achieve goals. Unlike motion planning (which handles geometry), task planning deals with symbolic representations of states, actions, and goals. This section covers PDDL (Planning Domain Definition Language) and HTN (Hierarchical Task Network) planning.

## Overview

**Task Planning**: Find sequence of high-level actions to achieve goal

**Example**:
```
Goal: Robot has coffee
Actions: [navigate_to(kitchen), find(coffee_maker), pour(coffee), grasp(cup),
          navigate_to(user), deliver(cup)]
```

**Compared to Motion Planning**:
- Motion: How to move (geometry, collision-free paths)
- Task: What to do (action sequencing, preconditions, effects)

## PDDL: Planning Domain Definition Language

PDDL is a standard language for specifying planning problems.

### Components

**Domain**: Defines actions, predicates, and types

**Problem**: Specifies initial state, objects, and goal

### Example: Robot Manipulation

**Domain (domain.pddl)**:
```lisp
(define (domain robot-manipulation)
  (:requirements :strips :typing)
  (:types robot location object)

  (:predicates
    (at ?r - robot ?l - location)
    (object-at ?o - object ?l - location)
    (holding ?r - robot ?o - object)
    (empty-hand ?r - robot)
  )

  (:action pick-up
    :parameters (?r - robot ?o - object ?l - location)
    :precondition (and
      (at ?r ?l)
      (object-at ?o ?l)
      (empty-hand ?r)
    )
    :effect (and
      (holding ?r ?o)
      (not (object-at ?o ?l))
      (not (empty-hand ?r))
    )
  )

  (:action put-down
    :parameters (?r - robot ?o - object ?l - location)
    :precondition (and
      (at ?r ?l)
      (holding ?r ?o)
    )
    :effect (and
      (object-at ?o ?l)
      (empty-hand ?r)
      (not (holding ?r ?o))
    )
  )

  (:action move
    :parameters (?r - robot ?from - location ?to - location)
    :precondition (at ?r ?from)
    :effect (and
      (at ?r ?to)
      (not (at ?r ?from))
    )
  )
)
```

**Problem (problem.pddl)**:
```lisp
(define (problem fetch-cup)
  (:domain robot-manipulation)
  (:objects
    robot1 - robot
    kitchen living-room - location
    cup1 - object
  )
  (:init
    (at robot1 living-room)
    (object-at cup1 kitchen)
    (empty-hand robot1)
  )
  (:goal
    (and
      (at robot1 living-room)
      (holding robot1 cup1)
    )
  )
)
```

**Solution** (generated by planner):
```
1. move(robot1, living-room, kitchen)
2. pick-up(robot1, cup1, kitchen)
3. move(robot1, kitchen, living-room)
```

### PDDL Planners

**Fast-Forward (FF)**: Heuristic search planner
```bash
ff -o domain.pddl -f problem.pddl
```

**Fast-Downward**: State-of-the-art planner
```bash
./fast-downward.py domain.pddl problem.pddl --search "astar(lmcut())"
```

**LAMA**: Combines multiple heuristics
```bash
./fast-downward.py domain.pddl problem.pddl --alias lama-first
```

## HTN: Hierarchical Task Network Planning

HTN planning decomposes high-level tasks into lower-level subtasks.

### Concepts

**Primitive Tasks**: Directly executable actions (e.g., grasp, move)

**Compound Tasks**: Decomposed into subtasks (e.g., fetch-object)

**Methods**: Decomposition rules (how to achieve compound task)

### Example: Making Coffee

```python
# Compound task: make-coffee
task_make_coffee = CompoundTask(
    name="make-coffee",
    methods=[
        Method(
            name="method1",
            subtasks=[
                "navigate-to(kitchen)",
                "locate(coffee-maker)",
                "grasp(coffee-grounds)",
                "pour(coffee-grounds, coffee-maker)",
                "press-button(coffee-maker)",
                "wait(30)",
                "grasp(cup)",
                "pour(coffee, cup)",
            ]
        )
    ]
)

# Primitive task: grasp
action_grasp = PrimitiveTask(
    name="grasp",
    parameters=["object"],
    preconditions=["at-object-location", "hand-empty"],
    effects=["holding(object)", "not hand-empty"]
)
```

### HTN Planner (SHOP2)

```python
from pyhop import pyhop

# Define operators (primitive actions)
def grasp(state, robot, obj):
    if state.at[robot] == state.obj_loc[obj] and state.holding[robot] is None:
        state.holding[robot] = obj
        state.obj_loc[obj] = None
        return state
    return False

# Define methods (decomposition)
def fetch_object(state, robot, obj, goal_loc):
    current_loc = state.at[robot]
    obj_loc = state.obj_loc[obj]

    if obj_loc is not None:
        return [
            ('navigate', robot, obj_loc),
            ('grasp', robot, obj),
            ('navigate', robot, goal_loc),
            ('release', robot, obj)
        ]
    return False

# Declare methods
pyhop.declare_methods('fetch-object', fetch_object)
pyhop.declare_operators(grasp, release, navigate)

# Plan
state = State(...)
plan = pyhop.pyhop(state, [('fetch-object', 'robot1', 'cup', 'table')])
```

## Classical Planning vs HTN

| Feature | Classical (PDDL) | HTN |
|---------|------------------|-----|
| Representation | States, actions, goals | Tasks, methods, decomposition |
| Search | State space | Task decomposition |
| Expressiveness | Limited | High (procedures, control) |
| Efficiency | Slower for complex domains | Faster (heuristics encoded) |
| Common Use | General planning | Domain-specific planning |

## Temporal Planning

Planning with time and concurrent actions.

**PDDL 2.1** adds:
- Durative actions (actions with duration)
- Continuous effects
- Metric optimization

**Example**:
```lisp
(:durative-action charge-battery
  :parameters (?r - robot ?station - charging-station)
  :duration (= ?duration 300)  ; 5 minutes
  :condition (and
    (at start (at ?r ?station))
    (over all (at ?r ?station))
  )
  :effect (and
    (at end (charged ?r))
  )
)
```

## Integration with Robotics

### ROSPlan

ROS package for task planning:

```python
import rospy
from rosplan_dispatch_msgs.srv import DispatchService
from rosplan_knowledge_msgs.srv import KnowledgeUpdateService

# Add facts to knowledge base
rospy.wait_for_service('/rosplan_knowledge_base/update')
update_kb = rospy.ServiceProxy('/rosplan_knowledge_base/update', KnowledgeUpdateService)

# Add: robot is at kitchen
update_kb(update_type=0, knowledge_type=1,
          attribute_name='at',
          values=['robot1', 'kitchen'])

# Generate plan
rospy.wait_for_service('/rosplan_planner_interface/planning_server')
plan_service = rospy.ServiceProxy('/rosplan_planner_interface/planning_server',
                                  PlanningService)
plan_service()

# Execute plan
rospy.wait_for_service('/rosplan_plan_dispatcher/dispatch_plan')
dispatch = rospy.ServiceProxy('/rosplan_plan_dispatcher/dispatch_plan', DispatchService)
dispatch()
```

### Task-Motion Planning (TMP)

Combines task planning with motion planning:

```python
def task_motion_planning(initial_state, goal):
    # Task planner generates high-level plan
    task_plan = task_planner(initial_state, goal)

    for action in task_plan:
        # Motion planner generates trajectory for each action
        if action.type == "navigate":
            trajectory = motion_planner(action.start, action.goal)
            if trajectory is None:
                # Backtrack: motion infeasible
                task_plan = replan(initial_state, goal, failed_action=action)
                continue

        elif action.type == "grasp":
            grasp_pose = grasp_planner(action.object)
            trajectory = motion_planner(current_pose, grasp_pose)
            if trajectory is None:
                task_plan = replan(initial_state, goal, failed_action=action)
                continue

        execute(trajectory)

    return task_plan
```

**Challenges**:
- Task planner may propose infeasible motions
- Motion planner doesn't understand task-level constraints
- Requires tight integration and backtracking

## LLM-Based Task Planning

Modern approach: Use large language models for task planning.

```python
def llm_task_planner(goal, context):
    prompt = f"""
    You are a robot task planner. Given a goal, generate a sequence of actions.

    Available actions:
    - navigate_to(location)
    - grasp(object)
    - place(object, location)
    - open(container)
    - close(container)

    Current state: {context}
    Goal: {goal}

    Generate a plan as a sequence of actions:
    """

    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}]
    )

    plan = parse_plan(response.choices[0].message.content)
    return plan
```

**Advantages**:
- No domain engineering (no PDDL domain definition)
- Natural language interface
- Common-sense reasoning

**Disadvantages**:
- No formal guarantees (may generate invalid plans)
- Requires validation and error handling
- Can't handle complex constraints

## VLA + Task Planning Integration

```python
def vla_with_task_planning(instruction):
    # LLM generates high-level task plan
    task_plan = llm_task_planner(instruction)

    for task in task_plan:
        # VLA model executes each task
        success = vla_execute(task)

        if not success:
            # Replan or ask for help
            task_plan = replan(instruction, failed_task=task)

    return task_plan
```

**Example**:
```
Instruction: "Make me breakfast"
    ↓
Task Planner: [get_pan, crack_egg, cook_egg, get_plate, serve]
    ↓
VLA Model: Executes each task with low-level control
```

## Tools and Libraries

**PDDL Planners**:
- Fast-Forward (FF)
- Fast-Downward
- LAMA

**HTN Planners**:
- SHOP2
- PyHop (Python)
- JSHOP2 (Java)

**ROS Integration**:
- ROSPlan
- FlexBE (Behavior Trees)

**Research Tools**:
- PDDLGym (RL + Planning)
- AI Planning Domain Benchmarks

## Summary

Task planning enables robots to reason about high-level action sequences. PDDL provides a standard language for classical planning, while HTN planning offers hierarchical decomposition. Modern approaches integrate LLMs for natural language task planning. Combining task planning with motion planning (TMP) and VLA models creates complete intelligent systems.

Next: [Reactive Planning](reactive-planning.md) - Learn real-time planning for dynamic environments.
